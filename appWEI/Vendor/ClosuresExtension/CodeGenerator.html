<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title></title>
	<script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
	<style type="text/css">
	.code {
		font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
		font-size: 12px;
		color: #333;
	}
	textarea {
		width: 800px;
		height: 400px;
	}
	</style>
</head>
<body>
<textarea id="taSource" class="code">
UIScrollView: NSObject, UIScrollViewDelegate

// MAKE: - UIScrollViewDelegate
    optional func scrollViewDidScroll(scrollView: UIScrollView) // any offset changes
    @availability(iOS, introduced=3.2)
    optional func scrollViewDidZoom(scrollView: UIScrollView) // any zoom scale changes
    
    // called on start of dragging (may require some time and or distance to move)
    optional func scrollViewWillBeginDragging(scrollView: UIScrollView)
    // called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest
    @availability(iOS, introduced=5.0)
    optional func scrollViewWillEndDragging(scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)
    // called on finger up if the user dragged. decelerate is true if it will continue moving afterwards
    optional func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool)
    
    optional func scrollViewWillBeginDecelerating(scrollView: UIScrollView) // called on finger up as we are moving
    optional func scrollViewDidEndDecelerating(scrollView: UIScrollView) // called when scroll view grinds to a halt
    
    optional func scrollViewDidEndScrollingAnimation(scrollView: UIScrollView) // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating
    
    optional func viewForZoomingInScrollView(scrollView: UIScrollView) -> UIView? // return a view that will be scaled. if delegate returns nil, nothing happens
    @availability(iOS, introduced=3.2)
    optional func scrollViewWillBeginZooming(scrollView: UIScrollView, withView view: UIView!) // called before the scroll view begins zooming its content
    optional func scrollViewDidEndZooming(scrollView: UIScrollView, withView view: UIView!, atScale scale: CGFloat) // scale between minimum and maximum. called after any 'bounce' animations
    
    optional func scrollViewShouldScrollToTop(scrollView: UIScrollView) -> Bool // return a yes if you want to scroll to the top. if not defined, assumes YES
    optional func scrollViewDidScrollToTop(scrollView: UIScrollView) // called when scrolling animation finished. may be called immediately if already at top

</textarea>
<br>
<input type="button" id="buttonConvert" value="转换">
<script type="text/javascript">
    function getSourceObj(sourceText) {
        // 清除不需要的信息
        sourceText = sourceText.replace(/\/\/.+/g, "");
        sourceText = sourceText.replace(/@availability/g, "");

        var sourceObj = {
            className: "",
            superClass: "",
            protocolNames: [""],
            funcs: [{
                oldName: "",
                newName: "",
                parameters: [{
                    name: "",
                    variate: "",
                    type: ""
                }],
                returnType: ""
            }]
        };


        // 解析类定义
        var re = /^ *(UI(\w+)): (\w+)(?:, \w+)+/;
        var result = re.exec(sourceText);
        if (result == null) {
            alert("缺少类定义信息");
            return
        }
        sourceObj.className = result[1];
        var classChildName = result[2];
        sourceObj.superClass = result[3];

        sourceText = sourceText.replace(re, "");

        // 解析协议
        sourceObj.protocolNames = [];
        re = /, (\w+)/g;
        var str = result[0];
        while ((result = re.exec(str)) !== null) {
            sourceObj.protocolNames.push(result[1]);
        }

        // 解析方法
        sourceObj.funcs = [];
        re = / *(?:optional )*func (\w+)\((\w+): (\w+)[^\n]+/g;
        while ((result = re.exec(sourceText)) !== null) {
            var funcStr = result[0];
            var reg = new RegExp(classChildName, "i");
            var funcObj = {
                oldName: result[1],
                newName: firstLetterUppercase(result[1].replace(reg, "")),
                parameters: [{
                    name: result[2],
                    variate: result[2],
                    type: result[3]
                }],
                returnType: undefined
            }

            // 最多的参数
            var pre = /,(?: (\w+))? (\w+): ([<>\w\!\?]+)/g;
            while ((r = pre.exec(funcStr)) !== null) {
                funcObj.parameters.push({
                    name: r[1] ? r[1] : r[2],
                    variate: r[2],
                    type: r[3]
                });
            }
            if (funcObj.newName.length <= 0) {
                // 使用第二个参数名作为方法名
                if (funcObj.parameters.length < 2) {
                    console.log(funcObj);
                    alert("无法解析，需要第二个参数来确定方法名。请看控制台日志");
                    return null;
                }
                if (funcObj.parameters[1].name.match(/([A-Z])/))
                    funcObj.newName = firstLetterUppercase(funcObj.parameters[1].name);
                else if (funcObj.parameters.length < 3) {
                    // 第二个参数不存在大写字母，及需要第三个参数来确定方法名
                    console.log(funcObj);
                    alert("无法解析，需要第三个参数来确定方法名。请看控制台日志");
                    return null;
                }
                else {
                    funcObj.newName = firstLetterUppercase(funcObj.parameters[1].name) + firstLetterUppercase(funcObj.parameters[2].name);
                }
            }

            // 返回类型
            r = / -> ([<>\w\!\?]+)/.exec(funcStr);
            if (r) {
                funcObj.returnType = r[1];
            }

            sourceObj.funcs.push(funcObj);
        }
        return sourceObj;
    }

    function firstLetterUppercase(str) {
        return str.substring(0,1).toUpperCase() + str.substring(1);
    }
    function getFuncReturnType(returnType) {
        return returnType ? returnType : "Void";
    }

    function getConvertContent(sourceObj) {
        // 扩展缩写名
        var EXT_NAME_ACRONYM = "ce";
        var CLASS_DELEGATE_NAME = sourceObj.className + "_Delegate"
        var resultContent = "";

        // 生成扩展类
        //      方法
        var funcStr = "";
        for (var i = 0; i < sourceObj.funcs.length; i++) {
            var funcObj = sourceObj.funcs[i];
            // 参数串
            var paramtStr = "";
            for (var j = 0; j < funcObj.parameters.length; j++) {
                var paramtObj = funcObj.parameters[j];
                if (paramtStr.length > 0)
                    paramtStr += ", ";
                paramtStr += paramtObj.variate + ": " + paramtObj.type;
            };

            funcStr += "\
    public func " + EXT_NAME_ACRONYM + "_" + funcObj.newName + "(handle: (" + paramtStr + ") -> " + getFuncReturnType(funcObj.returnType) + ") -> " + sourceObj.className + " {\n\
        " + EXT_NAME_ACRONYM + "." + funcObj.newName + " = handle\n\
        return self\n\
    }\n";
        };
        //      最终的扩展类
        resultContent = "\
extension " + sourceObj.className + " {\n\
    \n\
    private var " + EXT_NAME_ACRONYM + ": " + CLASS_DELEGATE_NAME + " {\n\
        struct Static {\n\
            static var AssociationKey: UInt8 = 0\n\
        }\n\
        if let obj = objc_getAssociatedObject(self, &Static.AssociationKey) as? " + CLASS_DELEGATE_NAME + " {\n\
            return obj\n\
        }\n\
        if let delegate = self.delegate {\n\
            if delegate is " + CLASS_DELEGATE_NAME + " {\n\
                return delegate as! " + CLASS_DELEGATE_NAME + "\n\
            }\n\
        }\n\
        let delegate = " + CLASS_DELEGATE_NAME + "()\n\
        self.delegate = delegate\n\
        objc_setAssociatedObject(self, &Static.AssociationKey, delegate, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN))\n\
        return delegate\n\
    }\n\
    \n\
" + funcStr + "\n\
}\n";

        // 生成代理对象
        //      生成协议串
        var protocolStr = sourceObj.protocolNames.join(", ");
        //      生成成员变量
        var classVarStr = "";
        for (var i = 0; i < sourceObj.funcs.length; i++) {
            var funcObj = sourceObj.funcs[i];
            // 参数串
            var paramtStr = "";
            for (var j = 0; j < funcObj.parameters.length; j++) {
                var paramtObj = funcObj.parameters[j];
                if (paramtStr.length > 0)
                    paramtStr += ", ";
                paramtStr += paramtObj.type;
            };

            classVarStr += "    var " + funcObj.newName + ": ((" + paramtStr + ") -> " + getFuncReturnType(funcObj.returnType) + ")?\n";
        };
        //      生成respondsToSelector内容
        var respondsStr = "";
        var count = 0, groupIndex = 1;

        for (var i = 0; i < sourceObj.funcs.length;) {
            var funcObj = sourceObj.funcs[i]
            // 头
            if (count === 0) {
                respondsStr += "\n        let funcDic" + groupIndex + ": [Selector : Any?] = [\n";
            }
            // 内容
            respondsStr += "            \""
            for (var j = 0; j < funcObj.parameters.length; j++) {
                var paramtObj = funcObj.parameters[j];
                respondsStr += (j === 0 ? funcObj.oldName : paramtObj.name) + ":";
            };
            respondsStr += "\" : " + funcObj.newName + ",\n";
            // 尾
            count++;
            i++;
            if (count >= 7 || i >= sourceObj.funcs.length) {
                respondsStr += "\
        ]\n\
        if let f = funcDic" + groupIndex + "[aSelector] {\n\
            return f != nil\n\
        }\n";
                count = 0;
                groupIndex++;
            }
        };
        //      生成实现协议方法
        var funcStr = "";
        for (var i = 0; i < sourceObj.funcs.length; i++) {
            var funcObj = sourceObj.funcs[i]
            // 参数串
            var parameterStr = "", argumentStr = "";
            for (var j = 0; j < funcObj.parameters.length; j++) {
                var paramtObj = funcObj.parameters[j];

                if (parameterStr.length > 0)
                    parameterStr += ", ";
                if (paramtObj.name === paramtObj.variate) {
                    parameterStr += (paramtObj.variate + ": " + paramtObj.type);
                }
                else
                    parameterStr += paramtObj.name + " " + paramtObj.variate + ": " + paramtObj.type;

                if (argumentStr.length > 0)
                    argumentStr += ", ";
                argumentStr += paramtObj.variate;
            };
            // 返回值
            var returnStr = funcObj.returnType ? " -> " + funcObj.returnType : "";
            funcStr += "\n\
    @objc func " + funcObj.oldName + "(" + parameterStr + ")" + returnStr + " {\n\
        " + (funcObj.returnType ? "return " : "") + funcObj.newName + "!(" + argumentStr + ")\n\
    }";
        };
        //      最终实现的协议对象
        resultContent += "\n\
class " + CLASS_DELEGATE_NAME + ": " + sourceObj.superClass + ", " + protocolStr + " {\n\
    \n" + classVarStr + "\n\
    \n\
    override func respondsToSelector(aSelector: Selector) -> Bool {\n\
        " + respondsStr + "\n\
        return super.respondsToSelector(aSelector)\n\
    }\n\
    \n" + funcStr + "\n\
}";

        return resultContent;
    }

	$("#buttonConvert").click(function(){
        var sourceObj = getSourceObj($("#taSource").val());
        console.log(sourceObj);
        var resultContent = getConvertContent(sourceObj);
        $("#taResult").val(resultContent);
	});
</script>
<br>
<textarea id="taResult" class="code"></textarea>
</body>
</html>